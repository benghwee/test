import java.io.RandomAccessFile;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;

public class SharedMemoryQueue {

    private static final int INT_SIZE = 4;
    private static final int QUEUE_CAPACITY = 1024;

    private static final int HEAD_OFFSET = 0;
    private static final int TAIL_OFFSET = HEAD_OFFSET + INT_SIZE;
    private static final int DATA_OFFSET = TAIL_OFFSET + INT_SIZE;
    private static final int TOTAL_SIZE = DATA_OFFSET + QUEUE_CAPACITY * INT_SIZE;

    private final FileChannel channel;
    private final MappedByteBuffer buffer;

    public SharedMemoryQueue(String filePath) throws Exception {
        RandomAccessFile file = new RandomAccessFile(filePath, "rw");
        file.setLength(TOTAL_SIZE);
        this.channel = file.getChannel();
        this.buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, TOTAL_SIZE);
    }

    public void enqueue(int value) throws Exception {
        try (FileLock lock = channel.lock()) {
            int tail = buffer.getInt(TAIL_OFFSET);
            if (tail >= QUEUE_CAPACITY) {
                throw new IllegalStateException("Queue is full");
            }

            int index = DATA_OFFSET + tail * INT_SIZE;
            buffer.putInt(index, value);
            buffer.putInt(TAIL_OFFSET, tail + 1);
            buffer.force();
        }
    }

    public int dequeue() throws Exception {
        try (FileLock lock = channel.lock()) {
            int head = buffer.getInt(HEAD_OFFSET);
            int tail = buffer.getInt(TAIL_OFFSET);

            if (head >= tail) {
                throw new IllegalStateException("Queue is empty");
            }

            int index = DATA_OFFSET + head * INT_SIZE;
            int value = buffer.getInt(index);
            buffer.putInt(HEAD_OFFSET, head + 1);
            buffer.force();
            return value;
        }
    }
}
